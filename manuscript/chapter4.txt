# Chapter 4 - I Have a Password Hash, Now What?

{width: 30%}
![](https://user-images.githubusercontent.com/46549513/162606300-527e8cff-8c23-43d6-b06b-8b43fd7c82f2.png)

By [John Haynes](https://www.youtube.com/channel/UCJVXolxwB4x3EsBAzSACCTg)

## Disclaimer / Overview

This chapter is a beginner’s guide on how to crack passwords. While on the surface this may seem to be something reserved for cybercriminals, there are legitimate reasons for a law-abiding individual to understand this process. Firstly, those who work in penetration testing or a red team environment will need to know how to do this task. Secondly, law enforcement may need to access data that is password protected with the legal authority of a search warrant. Third, important data may need to be recovered from a device after the owner is deceased for the estate or heirs. There may also be other ways to legally access password protected data such as forgotten passwords or security concerns in a courporate envornment. Finally, it is important for someone who wishes to keep their data secure to understand this process to know why a strong password is important and how to test the security of their passwords without compromising those passwords. 

That being said, I do not condone, encourage, or support those who would use this information for malicious or illegal means. This paper will start with the fundamentals of hashing and end with showing how a strong password makes a substantial difference when attempting to crack complex passwords. 

For those that need to legally access the data, there should be something in here for you. For those that wish to learn how to better secure their own data, there should be something in here for you as well. Let's get started!

## Password Hashes

At the fundamental level, a password is like a key that fits into and unlocks a particular lock. Only you have the key, but anyone can come up and inspect the lock. With a mechanical lock, nobody can see the internal functions of the lock without specialized tools like lock picks. If someone was proficient at using lockpicks, they could theoretically determine the depth of each pin while picking the lock to make a key that would unlock the lock.

The same sort of concept is true for passwords. Each password should have a unique algorithmic hash. To obtain a hash, a complex mathematical algorithm is run against a string of data and the output is an extremely unique character string. For some weaker hash algorithms, there have been hash collisions where two different sets of data have resulted in the same outputted hash. However, when considering human-generated passwords, it is normally not necessary to worry about hash collisions. It is sufficient to say that if you have the hash of a password you have the password in an encrypted state. The password hash is how the password is stored on any modern operating system like Windows, macOS, or Linux or for encrypted containers like Bitlocker or encrypted 7zip files. With the right tools, that is the only part of the password that will be available for an examiner to inspect, just like the external part of a lock is the only thing to inspect on a locked door if someone were to try and pick the lock. There are methods to prevent the extraction of a password hash, but it is reasonable to attempt to find a method to extract a hash from a system if the individual has physical access to the electronic device, encrypted file, or a forensic image (.E01, dd, or similar) of an encrypted volume.

Therefore, if the password hash can be extracted, it can be attacked to attempt to crack the password. Hashing algorithms are mathematically a one-way operation. If someone has a password hash, there is no normal mathematical operation that can be performed to reverse engineer the original plaintext password. Additionally, some hashing algorithms are more difficult to crack than others because the speed of decryption is sacrificed for security. However, the user can guess the potential password, hash it, and then compare the resulting hash against the known hash. If it is a match, then the password is cracked. This would be a very slow method to do manually, but there is software like Hashcat that can be used to automate this process to perform thousands of attempts per second. To make the guessing more difficult, the system can implement what is known as “salt” into the hash to obfuscate the hash and make it more difficult to crack.

A discussion of password hashes would not be complete without mentioning salted passwords. The salt for a password is additional data that is added to the password before the hash algorithm is applied to complicate the guessing of the password. Therefore, the salt would have to be known and applied to each potential guess otherwise the hash would be incorrect even if the correct password was guessed. The salt can be generated in several different ways and can be static or dynamic depending on developer choice. Unfortunately, Windows does not salt the NTLM password hashes that it generates so they are vulnerable to attack.

As was just mentioned, Windows stores password hashes in NTLM format. This is unfortunately a very weak form of encryption as it is the equivalent of MD4 encryption. The VTech company was compromised in 2015 by a SQL injection attack and when the password hashes were analyzed they were determined to be encrypted with MD5. MD5 is considered to be a weak form of encryption and some do not consider it to even be encryption as it is so weak.  Windows uses even weaker encryption for its passwords, and those passwords are not even salted to compensate for the weak encryption! Windows has upgraded to NTLMv1 and NTLMv2 for some uses, but those are still weak by most encryption standards. Even more concerning is these NTLM hashes of user passwords are transmitted over the network for authentication between computers (Patton, 2022). This is one of the most common passwords that users will use and can be extracted by several methods, including packet sniffing. It is also nearly guaranteed to not be generated by a password manager as the user has to physically enter the password into the keyboard. 

## Useful Software Tools

There is no reason to reinvent the wheel and in most situations, someone else has already created a tool that will perform the task needed. The general workflow for cracking a password is hash extraction, hash identification, attacking the hash with general methods, and attacking the hash with custom methods. Tools that can assist in these phases are Mimikatz, Hashcat, John the Ripper, Passware, Gov Crack, custom scripts often shared on GitHub and many more. Some tools like Passware are paid tools, and while there is nothing wrong with a paid tool this paper will focus on using the free tool called Hashcat. As was just mentioned, Gov Crack has a graphical user interface (GUI) while Hashcat and John the Ripper use command-line interfaces (CLI). Normally GUI interfaces allow for ease of access but tend to lack the flexibility of CLI tools. Nearly all of the custom scripts that are used for hash extraction and are posted on GitHub are going to be CLI-based tools. If the reader is unfamiliar with the command line, that should not be a limiting factor for at least understanding the methods discussed in this paper and there will be step-by-step instructions on how to crack a password hash in Hashcat. The focus on a particular set of tools over another is due to personal experience with certain tools and no bias towards any particular tool is intended as many tools can do the same thing and overlap with each other with certain functions.

## Hash Extraction Techniques

One common method to extract an NTLM hash is to use Mimikatz, but it is widely recognized as malware by most anti-virus software. Due to the volatile nature of Mimikatz, I will not be providing information on where to obtain it as I obtained my copy in person from a trusted source. However, if the individual has access to the forensic image (an .E01 or similar) of the hard drive of the computer, then Mimikatz should be used against the SAM and SYSTEM registry files found in C:\Windows\System32\Config, assuming Bitlocker or another form of encryption is not present. Even with live access to a machine, administrator rights and a forensic tool such as FTK Imager, preferably preloaded on a USB drive, will be required to copy the registry files as a simple copy/paste or drag-and-drop method will not work. This is just one way to obtain an NTLM hash as it can also be obtained by observing network traffic. In general, this is a great place to start when trying to crack passwords and try out different methods as the NTLM hash uses weak encryption.

If the examiner is looking at an APFS encrypted volume from a Macbook, it is important to realize that the password for the encrypted volume is the same as the password used to log into the system. However, this hash uses a strong encryption method and will take much longer to crack as compared to an NTLM hash. To extract the hash, there are tools available like the one from user Banaanhangwagen on GitHub. https://github.com/Banaanhangwagen/apfs2hashcat. This will require using Linux to run the tool and extract the hash from a raw or .dd forensic image.

Other strong encryption methods include Bitlocker, zipped or compressed files, and many more. Generally speaking, some smart person somewhere has found out how to extract the hash and has shared that information for that particular situation. The examiner needs to search for hash extraction of a particular make, model, file system, software version, or a combination of those and similar attributes. Also as a general rule, the hash is likely to be stored in plain text somewhere in the hex (the raw data) on an electronic device. If the examiner is willing to poke around and search the hex, they may be able to find the password hash assuming they are correctly decoding the hex. This is not a hard-fast rule by any means, as there are complex methods of preventing external access to protected memory areas. For example, I know of no known method at the time of writing this to extract a hash from a Chromebook even though it is possible to log into a Chromebook without it being connected to the internet, implying that a hash of the user’s password must be stored locally on the device.

## Hash Identification

There may be times when a password hash has been located but the hash type is unknown. Hashcat has an entire wiki including example hashes that can aid in this process. The example hashes are located at https://hashcat.net/wiki/doku.php?id=example_hashes and can help with the hash identification of an unknown hash. A simple Google search for “Hash Identification” results in multiple online tools that can help identify the type of hash, be it NTLM, SHA-256, or many others. Several websites include https://nth.skerritt.blog/, https://hashes.com/en/tools/hash_identifier, or https://www.onlinehashcrack.com/hash-identification.php. Be wary of using these or any other websites for sensitive hashes as the website now has the actual hash. For advanced examiners who do not want to use an online tool, Kali Linux also has an offline tool that can be downloaded and used locally.

## Attacking the Hash

Once the type of hash is identified, it is time to attempt to crack the hash. The simplest yet least secure method of cracking a password from a hash is once again to use an online resource. Some of the previously mentioned websites also offer services that will attempt to crack a hash, but those are limited. The use of a password cracking tool such as Hashcat is highly recommended as it allows for a much more powerful, robust, and secure method of cracking a password hash.

Here is a hash taken from the Hashcat Wiki (b4b9b02e6f09a9bd760f388b67351e2b). This is an NTLM hash of a word in the English language. If you have visited the website then it is easy to determine what this hash is, but let's assume that we know nothing about this hash other than it was extracted from a machine and we wanted to crack this hash using Hashcat. Recall that the method of cracking this password has to be coming up with our potential password, hashing it, and comparing the two hashes until we find a match. This is a process Hashcat will automate for us. So if we get it wrong, the worst that will happen is we will move on to the next potential password and try again. Therefore, there are two primary methods of attacking a password, a brute-force method, and a more focused attack. An exhaustive brute-force attack would take the combination of all possible symbols on the keyboard and iterate through them. This is not ideal, but let's explore the mathematical reason why it is not the best method before explaining a better method.
  
If an exhaustive attack was to be performed against a password, that would mean that every possible permutation of all possible characters, numbers, and symbols on the keyboard would be attempted. For the standard English QWERTY keyboard, there are 10 digits “0123456789”, 26 lowercase letters “abcdefghijklmnopqrstuvwxyz”, 26 upper case letters, “ABCDEFGHIJKLMNOPQRSTUVWXYZ”, and 33 special characters or including symbols, “!@#$%^&*()-_=+[{]}\|;:'”,<.>/? “. Note that space or the spacebar is also included in the special character count. Adding these together results in 10 + 26 + 26 + 33 = 95 or ninety-five total possible characters that can be used at any point in a password, assuming they are all allowed for use in a password. So for a single character password, there are only 95 possible combinations. For a two-character password, there are 95 x 95 = 9,025 possible combinations. A three-character password has 95 x 95 x 95 (or 953) = 857,375 combinations, a four-character has 954 = 81,450,625 combinations, and a very short five-character password has an astonishing 955 = 7,737,809,375 password combinations, over seven billion! Even a meager eight-character combination has over six quadrillion (a quadrillion is the name of the number just beyond trillion) possible combinations for just the eight characters alone! Not only does this show the difficulty of using every possible character, but it also shows the strength of using unusual symbols in passwords. Even with modern computing that is capable of computing thousands of possible passwords per second, it could take decades or longer to attempt to crack an eight-character password using this method using normal computers. We need a better method!
  
So to speed up this process we need to make some assumptions about the original password rather than guessing random characters. This brings up the primary weakness and therefore the best method of attacking passwords once the examiner has the hash. Since most passwords must be remembered by the user, it is very likely to contain a word in a language that the user knows. The total number of guesses can be greatly reduced by avoiding letter combinations that are not words. The total number of words in the 2022 Oxford English dictionary is over 600,000 words, but this does include outdated, obsolete, and obscure words. Still, this is a huge improvement over even a short three-letter permutation!
  
It is also common to add numbers or symbols to the end of the password. So we can also add numbers to the end of a valid word and try those combinations. Sophisticated users may decide to use “leet speak” and replace letters like 'S' with the number '5', the letter 'A' with the number '4', the letter 'E' with the number '3', the letters 'I' or 'l' with the number '1' because they look similar to the corresponding letter. For example, the word “Apples” may become “4pp135” Finally, the addition of symbols is common at the end of the password, so common symbols like “!” can be added to the end (Picolet, 2019). This is by no means an exhaustive list, but this is a good starting point considering the alternative of a true brute force attack.

## Wordlists

Now that we know a better method, we need to come up with a way to use that method to attack passwords. The simplest method would be to use a list of words or a wordlist of possible passwords. Just like it sounds, it is a list of possible passwords that already have symbols and numbers added to them. When using a wordlist to attack a password, it is known as a dictionary attack. It is possible to manually build our wordlist, but that is a very time-intensive task as we would not only need to create useful passwords but avoid duplicates. Fortunately, there are prebuilt wordlists that we can use.

When companies are hacked, a part of the data that is often stolen is the passwords. Companies should encrypt their data, specifically user passwords, but this is not always the case.  In 2009, the social gaming company RockYou was compromised by a SQL injection attack. The hacker was able to gain access to over 32 million accounts and they were storing passwords in the clear, which means that there was no encryption whatsoever on the passwords as they were stored in plain text (Cubrilovic, 2009). This list of passwords has become known as the rockyou list and is commonly used as a starting point for dictionary attacks. Future breaches where the passwords have been compromised and cracked have also been added to wordlists. It is important to note that a good password list will not have duplicates of passwords, or the passwords have been deduplicated. This is a key way to save time when cracking passwords.
  
A good online resource where wordlists are compiled and ranked is Weakpass.com https://weakpass.com/ (W34kp455, 2014). On this site, wordlists are ranked by order of popularity and functionality from 0 to 100 and using a color-coding system that corresponds with the numerical ranking. Note how there are varying sizes of lists, ranging from over 400GB to only a few bytes in size. The first several wordlists for download may not be ranked very high being color-coded red and only being in the single digits. Selecting “Lists” and selecting “Medium” should display the original rockyou wordlist as rockyou.txt on the first page with just over 14 million unique passwords. When selecting “Lists” from the horizontal menu and selecting “All” we can sort all lists by popularity. Near the top of the list should be the “cyclone.hashesorg.hashkiller.combined.txt” password list with about 1.5 billion total passwords. This list is one of the top-ranked lists while only being just over 15GB in size. I would recommend using this list and I use it frequently due to its good combination of reduced size compared to other lists and overall speed in password cracking. The total time to iterate through the list is not unreasonable for many password hash types and stands a decent chance of cracking the password with a straight dictionary attack. The All-in-One tab allows for downloading a deduplicated version of all passwords on the site in various lengths for different applications, but know that a longer list will take longer to complete than a shorter list. If you haven't noticed, there is also an estimated time to iterate through the list for a particular password type under each list. While this can vary widely between different computers, it does a good job of showing the relative time difference it takes to attempt that list against the different hash types. If the 15GB password list is too large for you, another smaller list that is not posted on weakpass.com can be found at https://github.com/FullTang/AndroidPWList. This list combines several of the smaller wordlists from Weakpass and uses a few other techniques for an uncompressed size that is just under 1GB in size. If you plan on installing and using Hashcat, I would strongly recommend downloading at least one list of your choice.

## Installing Hashcat

Now that we know some of the more common methods used to create passwords, and we have access to a good list of millions of potential passwords, we can attempt to crack the example hash using Hashcat. The most recent version of Hashcat can be securely downloaded at https://hashcat.net/hashcat/ (Hashcat - Advanced Password Recovery, n.d.). Considering the type of calculations performed, it is much more efficient to use the video card of a computer to perform these calculations rather than use the CPU. This may cause some compatibility issues, and fixing those issues is beyond the scope of this writing. I would encourage anyone who has not used Hashcat or even if they have not used a command-line tool to follow along at this point on their own Windows machine even if you have not extracted any hashes up to this point. We will crack the previously mentioned example hash (b4b9b02e6f09a9bd760f388b67351e2b) from Hashcat's website here shortly!

Once Hashcat is installed, it needs to be launched from the command line, or command prompt, assuming the user is using a Windows system. The simplest method to launch a command prompt window in the correct location is to navigate to the where Hashcat is installed (C:\Windows\Programs\hashcat-6.2.5 or similar) using File Explorer, click the white area next to the path so that the path turns blue, type “cmd” without the quotes, and press enter. A black window with white text should appear. If you have never used the command line before, congratulations on opening your first terminal window!

The next step is to launch Hashcat in help mode. This will also see if the correct drivers are installed to allow for Hashcat to run. Simply type “hashcat.exe -h” in the command line without the quotes. It is possible that an error occurred stating an OpenCL, HIP, or CUDA installation was not found. If this is the case, I would recommend typing “device manager” in the search bar next to the Windows Start menu and then selecting “Display adapters” to determine the type of video card installed on the computer. Beyond this, it will require downloading the required drivers from a trusted source to continue using Hashcat. Additional help on how to install Hashcat can be found on the Hashcat Discord server at the following link: https://discord.gg/vxvGEMuemw.
If the “hashcat.exe -h” is successful, then there should be a large amount of output on the screen showing options, hash modes, and examples, and should end with some links to the Hashcat website. I find it helpful to save this help information to a simple text file for easy reference. That can be done by pressing the up arrow on the keyboard to display “hashcat.exe -h” again, but before pressing enter add “> Help.txt” to the end of the command for the total command of “hashcat.exe -h > Help.txt”. This will create a text file in the same folder with the output from the help command which can be opened in Notepad or similar for quick reference while keeping the command prompt window free to run Hashcat. 

Open the Help.txt that was just created in the hashcat-6.2.5 folder. Under - [ Hash Modes ] - it shows the numerous types of hashes that can be attacked (and possibly cracked) assuming the hash is properly extracted. Scrolling to the bottom shows some example commands to run Hashcat under - [ Basic Examples ] -. Note that the first Attack-Mode is a Wordlist, but there is also a Brute-Force option. This is not a true brute force method as was discussed earlier as it does not use all the possible symbols on the keyboard nor does it use uppercase letters except for the first character. One advantage is that it does not require a dictionary or wordlist to crack a password, so it has its uses. Let's break down this command.

Under example command, the first word is “hashcat”. It can also be “hashcat.exe”. This is simple, we are just calling the executable file, but we need to give some input or arguments to the program. The next thing we see is “-a” and then a number followed by “-m” followed by another number. At the top of the help file, we see under - [ Options ] - it explains “-a” as the attack-mode and “-m” as the hash-type. Both of these are required, but the order is not an issue as they be in either order, but we will follow the order shown in the example. Scrolling back down towards the bottom we find - [ Attack Modes ] - where it shows the types of attacks. Brute-Force is 3 while Straight is 0. Brute-Force is Hashcat's version of brute-force that was just discussed, while Straight is a dictionary attack using a wordlist. Now for the other required argument, the “-m”. This stands for hash-type, so we scroll up to the bulk of the help file under - [ Hash Modes ] - and see all the different types. We know this is an NTLM hash, so we need to find the hash-type for NTLM in all of that noise. Rather than manually searching, press CTRL + F to open the find menu and type “NTLM” (without the quotes). You may get some results like “NetNTLMv1”, “NetNTLMv1+ESS”, or  “NetNTLMv2” and you may have to change your direction of searching to find matches, but you should be able to find just NTLM all on one line with a mode of 1000. Now that we know the required parameters for our two required arguments, onto how to input the hash itself into Hashcat.

When it comes to the hash itself, Hashcat will accept the hash in one of two ways. It can either be pasted directly into the command line, or it can be put into a simple text file (.txt) with one hash (and only one hash) per line. If a text file is used, it needs to be all hashes of the same type, like multiple NTLM hashes or multiple SHA-256 hashes, with each hash on its own line. If attacking multiple hashes, the file method will be faster than trying to crack them one at a time but it will be slower than a single hash. Pasting directly into the command line can be faster if the hash is already extracted, but a few seconds taken to format the hash in a text file right after extraction may be better in some situations.
  
The example hash shows some arguments like ?a?a?a?a?a? after the “example0.hash”, but those are not required. Other arguments can be seen towards the top of the help file, but those are optional. We now know everything required to crack this example NTLM hash! (b4b9b02e6f09a9bd760f388b67351e2b).

## “Brute-Forcing” with Hashcat

Go to the command line where we typed in hashcat.exe -h and type hashcat.exe -a 3 -m 1000 b4b9b02e6f09a9bd760f388b67351e2b and hit enter. There should be a wall of white text and then it will stop and it should show “Cracked” partway up on the screen! Above the Cracked notification, there will be the hash and at the end, it will show “:hashcat” or “b4b9b02e6f09a9bd760f388b67351e2b:hashcat” without the quotes. This means the password was hashcat, as can be seen at the top of the Hashcat Wiki webpage. If this is your first time cracking a password then congratulations! You just cracked your first password hash! Now let's examine what Hashcat did during that wall of white text.

Scrolling up we can see the first block of text similar to the block of text at the end, but instead of saying “Cracked” it says “Exhausted”. Looking at the “Guess.Mask” row in the first column we see a “?1 [1]”, and on the next row we see a “Guess.Charset”. On the “Guess.Charset” row there it shows the -1 and it is followed by a ?l?u?d. To know what those mean, we need to go back to our help file. Under - [ Built-in Charsets ] - close to the bottom we see the “l” showing all lowercase characters, the “u” showing all uppercase characters, and the “d” is all digits from 0 to 9. Putting it all together this means Hashcat tried all lowercase, uppercase, and digits for a password length of 1 before exhausting and moving on. Notice how at the top it showed “Approaching final keyspace - workload adjusted.” and that means that Hashcat realizes it is about to come to the end of its current process and it is thinking about what it needs to do next.

The second block shows a Guess.Mask of ?1?2 [2]. Therefore, there was a total of two characters, but this time it is a little different. The ?2 is only the ?l and ?d meaning for the second character it only tried lowercase and digits, but for the first character it was still a ?1 so it tried lower, upper, and digits like in the first block. The third block is a Guess.Mask of ?1?2?2 [3], so three characters total but only trying uppercase, lowercase, and digits for the first and trying lowercase and digits for the other two. The fourth, fifth, and sixth blocks all show uppercase, lowercase, and digits for the first character with lowercase and digits for the rest. The seventh block is where it was cracked, using the same Guess.Mask format of ?1?2?2?2?2?2?2. The password was not long enough to see for this example, but if we didn't crack it on seven characters it would keep getting longer, and eventually the ?3 would be used which would be added to the end which would also try five symbols, not the parentheses, of (*!$@_) in addition to lowercase and digits for the last character.

## Hashcat's Potfile

This worked for this password, but for more complicated passwords we can see where it has its limitations. That is why we need a robust wordlist. So let's try and crack this password again using a wordlist, and in doing so we will discover a useful function of Hashcat. First, find the wordlist that you previously downloaded in file explorer and unzip it. It may not have a file extension, but Hashcat doesn't care nor would it be likely that you could open the file in normal Notepad anyway as it is probably going to be too big for the standard version of Notepad. If you want to see the contents, you should be able to use another text editor like Notepad++ for smaller wordlists, but it is by no means required. Let's go back to the command line where we just cracked the hash and type out a new command. Type  “hashcat.exe -a 0 -m 1000 b4b9b02e6f09a9bd760f388b67351e2b “ not forgetting to put a single space after the hash but don't hit enter just yet. Hashcat needs the path for the wordlist, note how we are using -a 0 instead of -a 3. If you are savvy with the command line, you could enter the path of the file (not forgetting quotes if there are any spaces), or you could copy the path from the file explorer window (where we typed “cmd” earlier to open our command prompt window) and then add the file name, but there is an easier way that some may consider cheating. If you are not cheating you are not trying, right? The easiest way is to just drag and drop the uncompressed wordlist into the black area of the command prompt window and it should populate the whole path to the file in the command line. The whole command should look something like this, “hashcat.exe -a 0 -m 1000 b4b9b02e6f09a9bd760f388b67351e2b "D:\My Folder\My Downloaded Wordlist””. There may or may not be quotes around the path depending on if there are spaces in the folder and subfolders or the file name. Hit enter and see what happens.

It should have finished very quickly and displayed a notification of “INFO: All hashes found in potfile! Use --show to display them.”. Well, that is interesting, what is a potfile? Simply put, the potfile is where Hashcat automatically stores hashes it cracks with the corresponding password in plain text. This is very useful to make sure that time is not wasted trying to crack passwords that have already been cracked and to make sure a cracked password is saved in case of power failure. It would be most unfortunate if a password was cracked before the examiner could see it and the power went out to the machine that was not hooked up to a Universal Power Supply due to budgetary concerns. Anyway, go to the hashcat-6.2.5 folder where hashcat.exe is located, find the file named “hashcat.potfile” and open using Notepad or the text editor of your choice. Assuming this is your first time using a freshly downloaded Hashcat, there will only be one entry,  “b4b9b02e6f09a9bd760f388b67351e2b:hashcat. This is nice to prevent us from wasting time trying to crack it again, but we want to see how to try and crack it using other methods. Either delete the single entry from the potfile, save, and close, or just delete the whole potfile as Hashcat will automatically generate a new one upon cracking another password.

## Dictionary (Wordlist) Attack with Hashcat

Go back to the command prompt and press the up arrow on the keyboard. Your previously typed command of “hashcat.exe -a 0 -m 1000 b4b9b02e6f09a9bd760f388b67351e2b "D:\My Folder\My Downloaded Wordlist”” or similar should appear. Press Enter to run the command again. Now it should start processing, but it will stop after a moment and display something like “Watchdog: Temperature abort trigger set to 90c”. As a side note, this is nice to know that Hashcat has built-in safety procedures to help prevent the overheating of video cards and will slow down its processing speed if the GPU (aka video card) gets too hot. Anyway, after a few seconds, it should display something like “Dictionary cache building "D:\My Folder\My Downloaded Wordlist”: 1711225339 bytes (10.61%)” with the percentage increasing every few seconds. This is normal and depending on the size of the wordlist it might take a minute or two. This is required after the first time starting a new wordlist, but as long as the location of the wordlist does not change it will not need to build the dictionary each time. Once the dictionary is built, it will display the following line: “[s]tatus [p]ause [b]ypass [c]heckpoint [f]inish [q]uit =>” This shows what commands we can enter while it is processing. It would be nice to know what is going on, so press the 's' key.

The first thing I look at is the Time.Estimated row and it will show an estimated end date and time and estimated duration. This is where times can vary greatly based on the type of GPU and length of the wordlist. Even if a longer wordlist was chosen, it should not take long to crack the password  This is assuming that the word “hashcat” is in the dictionary, but hopefully it is there. This method will likely take a bit longer than the brute-force method, but it is much more robust and is one of the best methods for cracking passwords. We are going to try one more method for now, so go back to the potfile and delete the most recent entry from the potfile or just delete the whole potfile.

## Dictionary + Rules with Hashcat

The obvious weakness of the dictionary attack is the password has to be in a precompiled dictionary, but what if it is a complicated password not in a wordlist? What if the user made a password that used unusual symbols or used numbers at the beginning, used numbers instead of letters, or added an unusual number of symbols to the end? This can be cracked by Hashcat by using a combined dictionary and rule attack. Hashcat comes preloaded with rules, and additional rules can be downloaded just like wordlists can be downloaded. At this time, I have not found any rules that are noticeably superior to the rules that come standard with Hashcat but it is left up to the examiner to decide what they want to use.

After deleting the most recent entry in the potfile, check the “hashcat-6.2.5” folder and there should be a folder named “rules”. Inside the rules folder, there are plenty of prebuilt rules. My personal favorite is the “onerulestorulethemall” rule as the name rings home to me because of my short stature. It is also a good rule in general, but again there is mostly personal preference. It is worth mentioning that while these rules are only a few kilobytes in size, they can add a substantial amount of time to how long it takes to process a hash as all commands in each rule will be applied to each potential password in a wordlist. Just like with dictionary attacks, a bigger rule will take longer and yield more potential passwords but a smaller rule will be faster but with fewer generated passwords.

Go back to the command prompt and press the up arrow. Adding a rule to a dictionary attack is quite easy, we just need to add a “-r” followed by the path to the rule file after the dictionary at the end of the command. Just add -r to the end of the command, put a space, then drag and drop the rule of your choice into the command prompt window. The command should look something like “hashcat.exe -a 0 -m 1000 b4b9b02e6f09a9bd760f388b67351e2b "D:\My Folder\My Downloaded Wordlist” -r   D:\hashcat-6.2.5\rules\onerulestorulethemall.rule””. Once syntax looks good, press enter. This time the dictionary should not have to compile, as it will display “Dictionary cache hit:” and then information on the location of the dictionary. Press the “s” key on the keyboard to see the status, and note how the “Time.Estimated” row has increased, possibly to a day or more. Hopefully, it will not take longer than a few minutes to crack our example hash again. This method does take longer, but again we are attacking the hash in a way that will crack more complicated passwords than the other methods.

## Robust Encryption Methods

Up to now we have only cracked an NTLM hash, but what about more robust encryption methods? Go to the Hashcat Example Hashes webpage (https://hashcat.net/wiki/doku.php?id=example_hashes) and search for “Bitlocker” that should be mode 22100. The resulting hash should be “$bitlocker$1$16$6f972989ddc209f1eccf07313a7266a2$1048576$12$3a33a8eaff5e6f81d907b591$60$316b0f6d4cb445fb056f0e3e0633c413526ff4481bbf588917b70a4e8f8075f5ceb45958a800b42cb7ff9b7f5e17c6145bf8561ea86f52d3592059fb”. This is massive compared to the NTLM hash! Try it in Hashcat using the command “hashcat.exe -a 3 -m 22100 $bitlocker$1$16$6f972989ddc209f1eccf07313a7266a2$1048576$12$3a33a8eaff5e6f81d907b591$60$316b0f6d4cb445fb056f0e3e0633c413526ff4481bbf588917b70a4e8f8075f5ceb45958a800b42cb7ff9b7f5e17c6145bf8561ea86f52d3592059fb” without the quotes. The brute-force starts at four characters, because BitLocker originally required a minimum password length of four so Hashcat is smart enough to not waste time with trying less than four characters when attacking a BitLocker password. For my computer it shows an estimated time of 1 hours 19 minutes for just 4 characters! If I let it run and go to 5 characters, it shows it will take 2 days to just try 5 characters! Your computer may have different estimated times, but unless you have a really good gaming computer or are running Hashcat on a computer designed for mining cryptocurrency you are probably seeing similar numbers. Trying the same Bitlocker hash but just using a dictionary attack with no rules against the cyclone.hashesorg.hashkiller.combined dictionary shows an estimated time of 28 days!

Knowing this means that if an NTLM hash was cracked using the cyclone.hashesorg.hashkiller.combined dictionary, it will take about a month at the most for the same Bitlocker password to be cracked  This time can be significantly reduced by using a computer with multiple GPUs like computers used for mining cryptocurrency. This is a really good reason to not have a password that comes standard in most dictionary attacks and shows why strong and complicated passwords are important.

This is just examining Bitlocker, but VeraCrypt and DiskCryptor example hashes require the download of a file as it is too large to display on Hashcat's website. This shows a substantial difference between password encryption used by Windows and robust encryption software, but it also shows why it is very important to not reuse passwords. If an attacker can compromise the weak Windows password and it is the same password that is used for robust encryption software then it defeats the strong encryption method. It also shows how a robust encryption method can be defeated by a good wordlist and shows why strong passwords are the first line of defense no matter what encryption method is used.

## Complex Password Testing with Hashcat

Maybe you have gotten the bug by now and our simple hash that is just “hashcat” is not good enough and you want to try even harder potential passwords. The easiest way to attempt to crack more difficult passwords is to use an NTLM hash generator. Online NTLM hash generators hosted on a website may be the easiest route, but there is a major security concern if the user wants to test their own passwords and converts them using an online tool. By using the online tool the user has likely given up their password to a third party if that online tool is logging input to their website. I would only recommend using an online tool for testing passwords that the user is not using, and I would not even use similar passwords to ones that are currently in use in an online tool.

The next best method would likely be PowerShell functions or Python scripts that can generate NTLM hashes. Searching Google can find these functions and scripts, but the methods for using them will not be discussed. This is much more secure as the processing to convert the password to an NTLM hash is done on the user's computer. Just note that if the password is cracked, it will be saved in the potfile so it would be wise to either delete the entry from the potfile or delete the potfile altogether once the testing session is complete.

## Searching a Dictionary for a Password

Since we have already mentioned that the main weakness of a password is it's existance in a wordlist, it might be nice to see if our current password or other potential password shows up in a dictionary. Since these wordlists are very large, it is difficult to find a program that will open them up to do a simple Ctrl + F to search the document to find the password. Fortunatally, the command line offers and easier way to search the contents of a file without opening the file. Using file explorer, navigate to the folder where you have downloaded and uncompressed a wordlist. Openup a command line window just like we did for running Hashcat by clicking the white area next to the path so that the path turns blue, type “cmd” without the quotes, and press enter. A black window with white text should appear. We are going to use the "findstr" command to search the contents of a dictionary. In the command line, type "findstr password " and then press [TAB] until the dictionary you want to search appears. The completed command should look somthing like "findstr password MyDiscitonary" without the quotes. Press enter. If you chose a common password it should output a wall of white text showing all passwords with that contain that password. If it just shows a blinking cursor, then it is searching trying to find a match. When you are able to type again, it has finished searching. 

This is a good way to check if a password exists in a dictionary or wordlist, but if the password does not show up that does not mean it can't cracked with that dictionary, but an approprate rule would have to be added in order to mangle the wordlist in a way that would cause the password to be guessed by Hashcat. Still, since dictionary attacks are the most common and the fastest method of cracking a password, it is a good yet simple test to see if the password is a strong password or not.

## Conclusion

This has just been a brief dive into showing how easy it is to crack simple passwords and hopefully will show why strong passwords are so important. The Windows operating system uses a weak form of encryption for its passwords, and this is a place to start when trying to crack passwords for fun or security testing purposes. Even with strong encryption methods, a weak password will not be sufficient to safeguard the data. Knowing these methods are out there to defeat user passwords should show the user why it is so important to use strong passwords and why it is a bad idea to reuse passwords between accounts. A better understanding of the attack methods against passwords should encourage everyone to use better security practices to safeguard their data.

## References

Cubrilovic, N. C. (2009, December 14). TechCrunch is part of the Yahoo family of brands. 	TechCrunch. Retrieved May 12, 2022, from 	https://techcrunch.com/2009/12/14/rockyou-hack-security-myspace-facebook-	passwords/

hashcat - advanced password recovery. (n.d.). Hashcat. Retrieved May 12, 2022, from https://hashcat.net/hashcat/

Patton, B. (2022, March 25). NTLM authentication: What it is and why you should avoid using it. The Quest Blog. Retrieved May 12, 2022, from https://blog.quest.com/ntlm-authentication-what-it-is-and-why-you-should-avoid-using-it/

Picolet, J. (2019). Hash Crack: Password Cracking Manual (v3). Independently published.

W34kp455. (2014). Weakpass. Weakpass. Retrieved May 12, 2022, from https://weakpass.com/

